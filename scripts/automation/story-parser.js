#!/usr/bin/env node

/**
 * Áî®Êà∑ÊïÖ‰∫ãËß£ÊûêÂô®
 * Ëß£ÊûêÁî®Êà∑ÊïÖ‰∫ãÂπ∂ÁîüÊàêÊäÄÊúØ‰ªªÂä°
 */

const fs = require('fs');
const path = require('path');

class StoryParser {
  constructor() {
    this.businessDomains = {
      'user': ['Áî®Êà∑', 'ÁôªÂΩï', 'Ê≥®ÂÜå', '‰∏™‰∫∫ËµÑÊñô', 'Ë¥¶Êà∑'],
      'gym': ['ÂÅ•Ë∫´Êàø', 'Âú∫È¶Ü', 'ÂÅ•Ë∫´', 'ËÆæÊñΩ', 'Âô®Êùê'],
      'booking': ['È¢ÑÁ∫¶', 'È¢ÑËÆ¢', 'Êó∂Èó¥', 'ËØæÁ®ã', 'ÊïôÁªÉ'],
      'game': ['ÁßØÂàÜ', 'ÊàêÂ∞±', 'Á≠âÁ∫ß', 'ÊéíË°åÊ¶ú', 'ÊåëÊàò'],
      'social': ['Á§æ‰∫§', 'ÊúãÂèã', 'ÂàÜ‰∫´', 'ËØÑËÆ∫', '‰∫íÂä®'],
      'payment': ['ÊîØ‰ªò', 'Ë¥πÁî®', '‰ºöÂëò', 'ËÆ¢Âçï', 'Ë¥¶Âçï']
    };
    
    this.techComponents = {
      'user': {
        backend: ['AuthModule', 'UserModule', 'UserController', 'UserService'],
        frontend: ['AuthComponent', 'ProfileComponent', 'LoginForm'],
        database: ['users', 'user_profiles', 'auth_tokens']
      },
      'gym': {
        backend: ['GymModule', 'GymController', 'GymService'],
        frontend: ['GymListComponent', 'GymCardComponent', 'GymSearchComponent'],
        database: ['gyms', 'gym_facilities', 'gym_programs']
      },
      'booking': {
        backend: ['BookingModule', 'BookingController', 'BookingService'],
        frontend: ['BookingComponent', 'CalendarComponent', 'TimeSlotComponent'],
        database: ['bookings', 'time_slots', 'booking_status']
      },
      'game': {
        backend: ['GameModule', 'GameController', 'GameService', 'AchievementService'],
        frontend: ['GameComponent', 'AchievementComponent', 'LeaderboardComponent'],
        database: ['user_points', 'achievements', 'game_records']
      },
      'social': {
        backend: ['SocialModule', 'SocialController', 'SocialService'],
        frontend: ['SocialComponent', 'FeedComponent', 'CommentComponent'],
        database: ['social_posts', 'comments', 'user_friends']
      },
      'payment': {
        backend: ['PaymentModule', 'PaymentController', 'PaymentService'],
        frontend: ['PaymentComponent', 'OrderComponent', 'InvoiceComponent'],
        database: ['orders', 'payments', 'invoices']
      }
    };
  }

  /**
   * Ëß£ÊûêÁî®Êà∑ÊïÖ‰∫ã
   * @param {string} userStory - Áî®Êà∑ÊïÖ‰∫ãÊñáÊú¨
   * @returns {Object} Ëß£ÊûêÁªìÊûú
   */
  parseUserStory(userStory) {
    console.log(`üìù Ëß£ÊûêÁî®Êà∑ÊïÖ‰∫ã: ${userStory}`);
    
    // ÊèêÂèñÁî®Êà∑ÊïÖ‰∫ãÁªÑ‰ª∂
    const storyComponents = this.extractStoryComponents(userStory);
    
    // ËØÜÂà´‰∏öÂä°Âüü
    const businessDomain = this.identifyBusinessDomain(userStory);
    
    // ÁîüÊàêÊäÄÊúØ‰ªªÂä°
    const technicalTasks = this.generateTechnicalTasks(storyComponents, businessDomain);
    
    // ÁîüÊàêAPIÂèòÊõ¥
    const apiChanges = this.generateApiChanges(storyComponents, businessDomain);
    
    // ÁîüÊàêÊï∞ÊçÆÂ∫ìÂèòÊõ¥
    const dbChanges = this.generateDbChanges(storyComponents, businessDomain);
    
    const result = {
      userStory,
      storyComponents,
      businessDomain,
      technicalTasks,
      apiChanges,
      dbChanges,
      estimatedHours: this.estimateEffort(technicalTasks),
      priority: this.determinePriority(userStory),
      testCases: this.generateTestCases(storyComponents, businessDomain)
    };
    
    console.log(`‚úÖ Ëß£ÊûêÂÆåÊàêÔºåËØÜÂà´‰∏öÂä°Âüü: ${businessDomain}`);
    return result;
  }

  /**
   * ÊèêÂèñÁî®Êà∑ÊïÖ‰∫ãÁªÑ‰ª∂
   */
  extractStoryComponents(userStory) {
    const patterns = {
      role: /‰Ωú‰∏∫\s*([^Ôºå,]*)/,
      goal: /ÊàëÂ∏åÊúõ\s*([^Ôºå,]*)/,
      benefit: /‰ª•‰æø\s*([^Ôºå,]*)/
    };
    
    const components = {};
    
    for (const [key, pattern] of Object.entries(patterns)) {
      const match = userStory.match(pattern);
      components[key] = match ? match[1].trim() : '';
    }
    
    return components;
  }

  /**
   * ËØÜÂà´‰∏öÂä°Âüü
   */
  identifyBusinessDomain(userStory) {
    const scores = {};
    
    for (const [domain, keywords] of Object.entries(this.businessDomains)) {
      scores[domain] = 0;
      keywords.forEach(keyword => {
        if (userStory.includes(keyword)) {
          scores[domain]++;
        }
      });
    }
    
    // ËøîÂõûÂæóÂàÜÊúÄÈ´òÁöÑ‰∏öÂä°Âüü
    return Object.keys(scores).reduce((a, b) => scores[a] > scores[b] ? a : b);
  }

  /**
   * ÁîüÊàêÊäÄÊúØ‰ªªÂä°
   */
  generateTechnicalTasks(components, domain) {
    const techComponents = this.techComponents[domain] || this.techComponents['user'];
    
    return {
      backend: techComponents.backend.map(component => ({
        component,
        action: this.determineAction(components.goal),
        files: this.generateBackendFiles(component, domain)
      })),
      frontend: techComponents.frontend.map(component => ({
        component,
        action: this.determineAction(components.goal),
        files: this.generateFrontendFiles(component, domain)
      })),
      database: techComponents.database.map(table => ({
        table,
        action: this.determineDatabaseAction(components.goal),
        migrations: this.generateMigrationFiles(table, domain)
      }))
    };
  }

  /**
   * Á°ÆÂÆöÊìç‰ΩúÁ±ªÂûã
   */
  determineAction(goal) {
    if (goal.includes('ÂàõÂª∫') || goal.includes('Ê∑ªÂä†') || goal.includes('Êñ∞Â¢û')) {
      return 'create';
    } else if (goal.includes('‰øÆÊîπ') || goal.includes('Êõ¥Êñ∞') || goal.includes('ÁºñËæë')) {
      return 'update';
    } else if (goal.includes('Âà†Èô§') || goal.includes('ÁßªÈô§')) {
      return 'delete';
    } else if (goal.includes('Êü•Áúã') || goal.includes('ÊòæÁ§∫') || goal.includes('ÂàóË°®')) {
      return 'read';
    }
    return 'create'; // ÈªòËÆ§‰∏∫ÂàõÂª∫
  }

  /**
   * Á°ÆÂÆöÊï∞ÊçÆÂ∫ìÊìç‰ΩúÁ±ªÂûã
   */
  determineDatabaseAction(goal) {
    const action = this.determineAction(goal);
    const migrations = [];
    
    switch (action) {
      case 'create':
        migrations.push('create_table', 'add_indexes');
        break;
      case 'update':
        migrations.push('alter_table', 'add_column');
        break;
      case 'delete':
        migrations.push('drop_column');
        break;
      default:
        migrations.push('create_table');
    }
    
    return migrations;
  }

  /**
   * ÁîüÊàêÂêéÁ´ØÊñá‰ª∂ÂàóË°®
   */
  generateBackendFiles(component, domain) {
    const basePath = `src/modules/${domain}`;
    
    if (component.includes('Controller')) {
      return [`${basePath}/${domain}.controller.ts`];
    } else if (component.includes('Service')) {
      return [`${basePath}/${domain}.service.ts`];
    } else if (component.includes('Module')) {
      return [`${basePath}/${domain}.module.ts`];
    }
    
    return [`${basePath}/${component.toLowerCase()}.ts`];
  }

  /**
   * ÁîüÊàêÂâçÁ´ØÊñá‰ª∂ÂàóË°®
   */
  generateFrontendFiles(component, domain) {
    const basePath = `frontend/src/components/${domain}`;
    
    return [
      `${basePath}/${component}.tsx`,
      `${basePath}/${component}.test.tsx`,
      `${basePath}/${component}.styles.ts`
    ];
  }

  /**
   * ÁîüÊàêËøÅÁßªÊñá‰ª∂
   */
  generateMigrationFiles(table, domain) {
    const timestamp = Date.now();
    return [
      `prisma/migrations/${timestamp}_${table}_${domain}.sql`
    ];
  }

  /**
   * ÁîüÊàêAPIÂèòÊõ¥
   */
  generateApiChanges(components, domain) {
    const action = this.determineAction(components.goal);
    const endpoints = [];
    
    switch (action) {
      case 'create':
        endpoints.push(`POST /api/${domain}s`);
        break;
      case 'read':
        endpoints.push(`GET /api/${domain}s`);
        endpoints.push(`GET /api/${domain}s/:id`);
        break;
      case 'update':
        endpoints.push(`PUT /api/${domain}s/:id`);
        endpoints.push(`PATCH /api/${domain}s/:id`);
        break;
      case 'delete':
        endpoints.push(`DELETE /api/${domain}s/:id`);
        break;
    }
    
    return {
      endpoints,
      authentication: this.requiresAuth(domain),
      rateLimit: this.requiresRateLimit(domain),
      validation: this.generateValidationRules(components, domain)
    };
  }

  /**
   * ÁîüÊàêÊï∞ÊçÆÂ∫ìÂèòÊõ¥
   */
  generateDbChanges(components, domain) {
    const tables = this.techComponents[domain]?.database || [];
    
    return {
      tables: tables.map(table => ({
        name: table,
        action: this.determineDatabaseAction(components.goal),
        columns: this.generateColumns(domain, table),
        indexes: this.generateIndexes(domain, table),
        relations: this.generateRelations(domain, table)
      })),
      seeds: this.generateSeeds(domain)
    };
  }

  /**
   * ÁîüÊàêÂàóÂÆö‰πâ
   */
  generateColumns(domain, table) {
    const commonColumns = [
      { name: 'id', type: 'UUID', nullable: false, primary: true },
      { name: 'created_at', type: 'TIMESTAMP', nullable: false },
      { name: 'updated_at', type: 'TIMESTAMP', nullable: false }
    ];

    const domainColumns = {
      'gym': [
        { name: 'name', type: 'VARCHAR(255)', nullable: false },
        { name: 'address', type: 'TEXT', nullable: true },
        { name: 'latitude', type: 'DECIMAL(10,8)', nullable: true },
        { name: 'longitude', type: 'DECIMAL(11,8)', nullable: true }
      ],
      'user': [
        { name: 'username', type: 'VARCHAR(100)', nullable: false, unique: true },
        { name: 'email', type: 'VARCHAR(255)', nullable: false, unique: true },
        { name: 'password_hash', type: 'VARCHAR(255)', nullable: false }
      ],
      'booking': [
        { name: 'user_id', type: 'UUID', nullable: false },
        { name: 'gym_id', type: 'UUID', nullable: false },
        { name: 'booking_time', type: 'TIMESTAMP', nullable: false },
        { name: 'status', type: 'ENUM', nullable: false }
      ]
    };

    return [...commonColumns, ...(domainColumns[domain] || [])];
  }

  /**
   * ÁîüÊàêÁ¥¢Âºï
   */
  generateIndexes(domain, table) {
    const indexes = ['idx_created_at'];
    
    const domainIndexes = {
      'gym': ['idx_location', 'idx_name'],
      'user': ['idx_email', 'idx_username'],
      'booking': ['idx_user_id', 'idx_gym_id', 'idx_booking_time']
    };
    
    return [...indexes, ...(domainIndexes[domain] || [])];
  }

  /**
   * ÁîüÊàêÂÖ≥ËÅîÂÖ≥Á≥ª
   */
  generateRelations(domain, table) {
    const relations = {
      'booking': [
        { type: 'belongsTo', model: 'User', foreignKey: 'user_id' },
        { type: 'belongsTo', model: 'Gym', foreignKey: 'gym_id' }
      ],
      'gym': [
        { type: 'hasMany', model: 'Booking', foreignKey: 'gym_id' }
      ],
      'user': [
        { type: 'hasMany', model: 'Booking', foreignKey: 'user_id' }
      ]
    };
    
    return relations[domain] || [];
  }

  /**
   * ÁîüÊàêÁßçÂ≠êÊï∞ÊçÆ
   */
  generateSeeds(domain) {
    return [`seeds/${domain}_seed_data.sql`];
  }

  /**
   * Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅËÆ§ËØÅ
   */
  requiresAuth(domain) {
    const publicDomains = ['gym']; // ÂÖ¨ÂºÄËÆøÈóÆÁöÑÂüü
    return !publicDomains.includes(domain);
  }

  /**
   * Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÈÄüÁéáÈôêÂà∂
   */
  requiresRateLimit(domain) {
    const highTrafficDomains = ['gym', 'booking'];
    return highTrafficDomains.includes(domain);
  }

  /**
   * ÁîüÊàêÈ™åËØÅËßÑÂàô
   */
  generateValidationRules(components, domain) {
    const rules = {
      'gym': {
        name: 'required|string|max:255',
        address: 'string',
        latitude: 'numeric|between:-90,90',
        longitude: 'numeric|between:-180,180'
      },
      'user': {
        username: 'required|string|min:3|max:50|unique',
        email: 'required|email|unique',
        password: 'required|string|min:8'
      },
      'booking': {
        gym_id: 'required|uuid|exists:gyms,id',
        booking_time: 'required|date|after:now',
        status: 'required|in:pending,confirmed,cancelled'
      }
    };
    
    return rules[domain] || {};
  }

  /**
   * ‰º∞ÁÆóÂ∑•‰ΩúÈáè
   */
  estimateEffort(technicalTasks) {
    let hours = 0;
    
    // ÂêéÁ´Ø‰ªªÂä°
    hours += technicalTasks.backend.length * 2;
    
    // ÂâçÁ´Ø‰ªªÂä°
    hours += technicalTasks.frontend.length * 3;
    
    // Êï∞ÊçÆÂ∫ì‰ªªÂä°
    hours += technicalTasks.database.length * 1;
    
    return Math.max(hours, 1); // ÊúÄÂ∞ë1Â∞èÊó∂
  }

  /**
   * Á°ÆÂÆö‰ºòÂÖàÁ∫ß
   */
  determinePriority(userStory) {
    if (userStory.includes('Á¥ßÊÄ•') || userStory.includes('Á´ãÂç≥')) {
      return 'high';
    } else if (userStory.includes('ÈáçË¶Å') || userStory.includes('ÂÖ≥ÈîÆ')) {
      return 'medium';
    }
    return 'low';
  }

  /**
   * ÁîüÊàêÊµãËØïÁî®‰æã
   */
  generateTestCases(components, domain) {
    const action = this.determineAction(components.goal);
    
    const testCases = {
      unit: [
        `${domain}Service should ${action} ${domain} successfully`,
        `${domain}Controller should handle ${action} request`,
        `${domain}Validation should validate input data`
      ],
      integration: [
        `${domain} API should ${action} ${domain} with valid data`,
        `${domain} API should reject invalid data`,
        `${domain} API should handle authentication`
      ],
      e2e: [
        `User should be able to ${action} ${domain} from UI`,
        `${components.role} should see ${components.goal} result`,
        `System should provide ${components.benefit}`
      ]
    };
    
    return testCases;
  }
}

// ‰∏ªÊâßË°åÂáΩÊï∞
async function main() {
  const userStory = process.argv[2];
  
  if (!userStory) {
    console.error('‚ùå ËØ∑Êèê‰æõÁî®Êà∑ÊïÖ‰∫ã');
    console.error('‰ΩøÁî®ÊñπÊ≥ï: node story-parser.js "Áî®Êà∑ÊïÖ‰∫ã"');
    process.exit(1);
  }
  
  try {
    const parser = new StoryParser();
    const result = parser.parseUserStory(userStory);
    
    // ËæìÂá∫ÁªìÊûúÂà∞GitHub Actions
    if (process.env.GITHUB_OUTPUT) {
      const output = process.env.GITHUB_OUTPUT;
      fs.appendFileSync(output, `features=${JSON.stringify(result.technicalTasks)}\n`);
      fs.appendFileSync(output, `api_changes=${JSON.stringify(result.apiChanges)}\n`);
      fs.appendFileSync(output, `db_changes=${JSON.stringify(result.dbChanges)}\n`);
    }
    
    // ‰øùÂ≠òËß£ÊûêÁªìÊûú
    const outputFile = path.join(process.cwd(), 'story-analysis.json');
    fs.writeFileSync(outputFile, JSON.stringify(result, null, 2));
    
    console.log('üìä Ëß£ÊûêÁªìÊûúÂ∑≤‰øùÂ≠òÂà∞ story-analysis.json');
    console.log('üéØ È¢Ñ‰º∞Â∑•‰ΩúÈáè:', result.estimatedHours, 'Â∞èÊó∂');
    console.log('üìà ‰ºòÂÖàÁ∫ß:', result.priority);
    
  } catch (error) {
    console.error('‚ùå Ëß£ÊûêÂ§±Ë¥•:', error.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = { StoryParser };