/// <reference types="node" />
import { MiniProgramCore, MiniProgramDevtools, MiniProgramSummer, ProjectConfigJSON } from '../types';
import WaitAble from '../utils/waitable';
type FileChange = (type: 'unlink' | 'unlinkDir' | 'add' | 'addDir' | 'change', targetPath: string) => void;
type ProjectEventEmitter = MiniProgramSummer.TypedEventEmitter<{
    fileChange: FileChange;
    optionsChange: any;
    precompileOptionsChange: any;
}>;
export declare abstract class BaseProject extends WaitAble implements MiniProgramCore.IProject {
    protected _nameMappingFromDevtools?: MiniProgramCore.IStringKeyMap<string> | undefined;
    protected _projectPath: string;
    protected _injectedPages: string[];
    protected _projectArchitecture: MiniProgramCore.IProjectArchitecture;
    protected _miniprogramRoot: string;
    protected _pluginRoot: string;
    protected _appid: string;
    protected _extAppid?: string | null;
    protected _type: MiniProgramCore.ProjectType;
    protected _privateKey: string;
    ignores: string[];
    protected _attr: any;
    packOptions?: {
        ignore: MiniProgramDevtools.IProjectConfigPackOption[];
        include: MiniProgramDevtools.IProjectConfigPackOption[];
    } | undefined;
    setting: MiniProgramDevtools.IProjectSetting;
    protected _dirSet: Set<string>;
    protected _fileSet: Set<string>;
    event: ProjectEventEmitter;
    get projectPath(): string;
    get injectedPages(): string[];
    get projectArchitecture(): import("../types").MiniProgramCI.IProjectArchitecture;
    get srcPath(): string;
    get pluginSrcPath(): string;
    get type(): import("../types").MiniProgramCI.ProjectType;
    set type(type: import("../types").MiniProgramCI.ProjectType);
    get appid(): string;
    set appid(id: string);
    get privateKey(): string;
    set privateKey(key: string);
    get miniprogramRoot(): string;
    set miniprogramRoot(root: string);
    get pluginRoot(): string;
    set pluginRoot(root: string);
    get nameMappingFromDevtools(): MiniProgramCore.IStringKeyMap<string> | undefined;
    set nameMappingFromDevtools(mapping: MiniProgramCore.IStringKeyMap<string> | undefined);
    attr(): Promise<any>;
    ready(): Promise<void>;
    protected getProjectType(attr: any, compileType: MiniProgramCore.ProjectType): import("../types").MiniProgramCI.ProjectType;
    getProjectConfig(): ProjectConfigJSON.IProjectConfigJSON;
    normalizeRootPath: (pathName?: string) => string;
    serialize(): Promise<MiniProgramCore.IProjectSerializeInfo>;
    abstract init(...args: any[]): void;
    abstract updateFileAndDirs(...args: any[]): void;
    updateFiles(): void;
    updateOptions(options: MiniProgramDevtools.IDevtoolsProjectInfo): void;
    protected cacheDirName(dirSet: Set<string>, dir: string): void;
    deleteDirOrFileOfSet(dirSet: Set<string>, fileSet: Set<string>, targetPath: string): void;
    getTargetPath(prefix?: string, filePath?: string): string;
    getFilesAndDirs(): {
        files: string[];
        dirs: string[];
    };
    exists(prefix?: string, filePath?: string): boolean;
    stat(prefix?: string, filePath?: string): MiniProgramCore.IStat | undefined;
    getAllFileInfo(prefix?: string): MiniProgramCore.IFileInfos;
    getFileList(prefix?: string, extName?: string): string[];
    getSrcFile(prefix: string, filePath: string): Buffer;
    getFile(prefix: string, filePath: string): Buffer;
    getJson<T = any>(prefix?: string, filePath?: string): T;
    getFileSize(prefix?: string, filePath?: string): number;
    getExtAppid(): Promise<string | void>;
    onFileChange(type: MiniProgramCore.IWatchEventType, targetPath: string): Promise<void>;
    clearCache(): void;
}
export {};
