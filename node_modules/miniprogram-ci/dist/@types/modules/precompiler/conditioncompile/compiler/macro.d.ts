/// <reference types="node" />
import { MiniProgramCore } from '../../../../types';
import { MacroDefine } from '../define';
import { BaseConditionCompiler } from './base';
declare enum IfType {
    If = 0,
    Elif = 1
}
declare class IfBlock {
    startIx: number;
    endIx: number;
    elifIxs: number[];
    elseIx: number | null;
    innerIfs: IfBlock[];
    constructor(startIx: number, endIx: number, elifIxs?: number[], elseIx?: number | null, innerIfs?: IfBlock[]);
    getIfRange(): [number, number];
    getElifRange(index: number): [number, number];
    getElseRange(): [number, number];
}
export declare class MacroConditionCompiler extends BaseConditionCompiler {
    getIFRegex: () => RegExp;
    getELSERegex: () => RegExp;
    getENDIFRegex: () => RegExp;
    getFefineRegex: () => RegExp;
    getFileDefines(content: string): MiniProgramCore.ITargetPlatformDefine;
    matchDefine(line: string): boolean;
    parseDefine(line: string): any;
    applyDefines(lines: string[]): void;
    findIFBlocks(lines: string[]): IfBlock[];
    parseIFBlock(lines: string[], ifBlockStart: number): IfBlock;
    matchIF(line: string, type?: IfType): boolean;
    parseIF(line: string): string;
    matchENDIF(line: string): boolean;
    matchELSE(line: string): boolean;
    applyIF(lines: string[], ifBlock: IfBlock, defines: MiniProgramCore.ITargetPlatformDefine, verbose?: boolean, filePath?: string): void;
    evaluate(condition: string, defines: MiniProgramCore.ITargetPlatformDefine): boolean;
    blankCode(lines: string[], start: number, end?: number): void;
    doCompile(opts: {
        filePath: string;
        content: Buffer;
        macroDefine: MacroDefine;
    }): string;
}
export {};
