import { PluginDriver } from '../pluginDriver';
import { MiniProgramSummer, MiniProgramDevtools, MiniProgramCore } from '../../../../types';
import Module from '../module';
import { SummerCompiler } from '../summer';
import { ResolveFileInfo, Resolver } from '../resolver';
import { Recorder } from '../../../../utils/progressRecorder';
import PersistCache from '../persistCache';
export declare enum FileType {
    JSON = "json",
    WXML = "wxml",
    WXSS = "wxss",
    WXS = "wxs",
    JS = "js"
}
export declare enum JSONType {
    APP = "app",
    Page = "page",
    EXT = "ext",
    SITEMAP = "sitemap",
    THEME = "theme"
}
type GraphType = 'miniprogram' | 'plugin' | 'other' | 'minigame';
export type FileInfo = ResolveFileInfo & {
    independentRoot: string;
    isBabelIgnore: boolean;
};
export interface IGraphOptions {
    type: GraphType;
    root: string;
    persistCache: PersistCache;
    plugins: MiniProgramSummer.SummerPlugin[];
    compiler: SummerCompiler;
}
export declare abstract class BaseGraph {
    pluginDriver: PluginDriver;
    modulesByPath: Map<string, Module>;
    root: string;
    rootPath: string;
    persistCache: PersistCache;
    type: GraphType;
    compiler: SummerCompiler;
    project: MiniProgramCore.IPreCompileProject;
    cachedModules: Map<string, MiniProgramSummer.ModuleJSON>;
    resolver: Resolver;
    private invalidated;
    private running;
    protected _whiteListConfig: Set<string> | undefined;
    protected conf: MiniProgramDevtools.IAppConf | MiniProgramDevtools.IGameConf | MiniProgramDevtools.IGamePluginConf | undefined;
    constructor(options: IGraphOptions);
    destroy(): void;
    clearCache(): void;
    protected ensureConf(recorder: Recorder): Promise<void>;
    getPackageFile(root: string): Promise<FileInfo[]>;
    protected abstract checkFilePackage(path: string): string;
    protected abstract getIndependentRoot(targetPath: string): string;
    private onFileChange;
    private invalidateModules;
    private loadModuleFromFile;
    private loadSourceForModule;
    protected doCompileSingleCode(info: FileInfo, sourceCode?: string): Promise<MiniProgramDevtools.CodeFile>;
    private getCodeFileTask;
    protected getCodeFiles(files: FileInfo[], recorder: Recorder, options?: MiniProgramCore.ICompileOptions & {
        useCache?: boolean;
        resultType?: MiniProgramCore.IResultType;
    }): Promise<MiniProgramDevtools.CodeFiles>;
    private readFile;
    private tranform;
    private generate;
    private optimize;
    private compress;
    compile(options: MiniProgramCore.ICompileOptions, recorder: Recorder): Promise<MiniProgramDevtools.ICompileResult>;
    compileWithFileList(options: MiniProgramCore.ICompileOptionsWithFileList, recorder: Recorder): Promise<MiniProgramDevtools.ICompileResult>;
    protected abstract getWhiteListConfig(): Promise<Set<string>>;
    getLocalFileList(): Promise<MiniProgramCore.IFileInfos>;
    private compileOther;
    private compileCodeWithoutJSON;
    private compileCodeWithoutJSONWithFileList;
    protected isBabelSettingIgnore(fileInfo: ResolveFileInfo): boolean;
    protected abstract onFileChangeForGraph(type: 'unlink' | 'unlinkDir' | 'add' | 'addDir' | 'change', path: string): void;
    abstract getConf(recorder: Recorder): Promise<MiniProgramDevtools.IAppConf | MiniProgramDevtools.IPluginConf | MiniProgramDevtools.IGameConf | MiniProgramDevtools.IGamePluginConf>;
    getDevCodeByFileList(recorder: Recorder, options: {
        fileList: string[];
    }): Promise<MiniProgramDevtools.CodeFiles>;
    getProdCodeByFileList(recorder: Recorder, options: {
        fileList: string[];
        resultType?: MiniProgramCore.IResultType;
    }): Promise<MiniProgramDevtools.CodeFiles>;
    abstract getDevCode(recorder: Recorder, options?: MiniProgramDevtools.IPackageCodeOptions): Promise<MiniProgramDevtools.CodeFiles>;
    abstract getProdCode(recorder: Recorder, options?: MiniProgramDevtools.IPackageCodeOptions & MiniProgramCore.ICompileOptions): Promise<MiniProgramDevtools.CodeFiles>;
    abstract compileSingleCode(filePath: string, sourceCode?: string): Promise<MiniProgramDevtools.CodeFile>;
    protected abstract compileJSON(options: MiniProgramCore.ICompileOptions, recorder: Recorder): Promise<{
        conf: any;
        jsons: Record<string, string>;
    }>;
    protected abstract compileJSONWithFileList(options: MiniProgramCore.ICompileOptionsWithFileList, recorder: Recorder): Promise<{
        conf: any;
        jsons: Record<string, string>;
    }>;
    protected abstract getLocalCodeFileList(): string[];
}
export {};
