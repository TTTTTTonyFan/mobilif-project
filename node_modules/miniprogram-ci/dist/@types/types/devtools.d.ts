/// <reference types="node" />
import { MiniProgramCore } from './core';
import { MiniProgramSummer, IBasicCodeExt } from './summer';
export declare namespace MiniProgramDevtools {
    type IBuildLogType = 'doing' | 'success' | 'error' | 'info' | 'warn';
    interface IAppConf {
        app: any;
        ext: any;
        packages: Record<string, any>;
        pages: Record<string, any>;
        comps: Record<string, any>;
        sitemap: any;
        theme: any;
    }
    type IFilterFactory = (resultType: MiniProgramCore.IResultType) => Promise<(graph: GraphId, abFilePath: string) => number>;
    interface IGameConf {
        app: any;
        packages: Record<string, any>;
    }
    interface IPluginConf {
        plugin: any;
        pages: Record<string, any>;
        comps: Record<string, any>;
    }
    interface IGamePluginConf {
        plugin: any;
    }
    type IShowBuildLog = (msgId: string, type: IBuildLogType, text: string) => void;
    type ProgressUpdate = (id: number | string, status: IBuildLogType, message: string) => void;
    type ISummerPluginConfig = Array<string | [string, MiniProgramSummer.SummerPluginOptions]>;
    type IBabelSetting = {
        outputPath?: string;
        ignore?: any[];
    };
    type ISWCSetting = {
        ignore?: string[];
        outputPath?: string;
        rc?: Record<string, any>;
    };
    interface IDevtoolsProjectInfo {
        appid: string;
        attr: any;
        compileType: MiniProgramCore.ProjectType;
        projectArchitecture: MiniProgramCore.IProjectArchitecture;
        miniprogramRoot: string;
        pluginRoot: string;
        summerPlugins: ISummerPluginConfig;
        setting: MiniProgramDevtools.IProjectSetting;
        packOptions?: {
            ignore: MiniProgramDevtools.IProjectConfigPackOption[];
            include: MiniProgramDevtools.IProjectConfigPackOption[];
        };
        injectedPages?: string[];
    }
    type GraphId = MiniProgramCore.ProjectType;
    type IGetConfOptions = {
        graphId: GraphId;
    };
    type ICompileSingleCodeOptions = {
        graphId: GraphId;
        filePath: string;
        sourceCode?: string;
    };
    type IGetCodeOptions = {
        graphId: GraphId;
        cacheMd5: Record<string, string>;
        package?: string;
    };
    type IGetCodeByFileListOptions = {
        graphId: GraphId;
        cacheMd5: Record<string, string>;
        fileList: string[];
    };
    interface IDevtoolsProject {
        id: string;
        appid: string;
        projectid: string;
        projectname: string;
        miniprogramRoot: string;
        pluginRoot?: string;
    }
    interface EventMsg {
        type: 'event';
        name: string;
        data: any;
    }
    interface ProgressMsg {
        type: 'progress';
        id: number;
        taskId: number;
        status: 'doing' | 'success';
        message: string;
    }
    interface RequestMsg {
        type: 'request';
        id: number;
        name: string;
        data: any;
    }
    interface LogMsg {
        type: 'log';
        id: string;
        status: IBuildLogType;
        text: string;
    }
    interface ResponseMsg {
        type: 'response';
        id: number;
        data: any;
        error?: any;
    }
    interface ReadyMsg {
        type: 'ready' | 'noReady';
        data?: any;
        error?: any;
    }
    interface InitMsg {
        type: 'init';
        data: any;
    }
    type SummerProcessMessage = InitMsg | RequestMsg | ResponseMsg | EventMsg | ProgressMsg;
    type IPackageCodeOptions = {
        package: string;
        partialCompilePath?: string[];
    };
    interface CodeFile {
        path: string;
        md5: string;
        code: string;
        map?: MiniProgramSummer.SourceMap | string;
        mtime?: number;
        jsTag?: {
            isLargeFile: boolean;
            isBabelIgnore: boolean;
            helpers: string[];
        };
    }
    interface CodeError {
        path: string;
        error: any;
    }
    type CodeFiles = Record<string, CodeFile | CodeError>;
    interface ICompilerStatus {
        codeExts: string[];
        codeConf: {
            [key in IBasicCodeExt]: {
                exts: string[];
                template?: {
                    ext: string;
                    content: string;
                };
            };
        };
    }
    type ICompileResult = Record<string, string | Buffer>;
    interface ITask {
        name?: string;
        data?: any;
        resolve: any;
        reject: any;
        progressUpdate?: ProgressUpdate;
    }
    interface IProjectConfigPackOption {
        type: string;
        value: string;
    }
    type Void<T> = T | undefined | null;
    interface IProjectSetting {
        localPlugins?: boolean;
        autoAudits?: boolean;
        condition?: boolean;
        es6?: boolean;
        minified?: boolean;
        newFeature?: boolean;
        postcss?: boolean;
        urlCheck?: boolean;
        scopeDataCheck?: boolean;
        uglifyFileName?: boolean;
        compileHotReLoad?: boolean;
        uploadWithSourceMap?: boolean;
        preloadBackgroundData?: boolean;
        scriptsEnable?: boolean;
        lazyloadPlaceholderEnable?: boolean;
        skylineRenderEnable?: boolean;
        compileWorklet?: boolean;
        nodeModules?: boolean;
        checkInvalidKey?: boolean;
        checkSiteMap?: boolean;
        enhance?: boolean;
        swc?: boolean;
        swcSetting?: ISWCSetting;
        disableSWC?: boolean | null | undefined;
        coverView?: boolean;
        showShadowRootInWxmlPanel?: boolean;
        babelSetting?: {
            ignore: string[];
            disablePlugins: string[];
            outputPath: string;
        };
        minifyWXMLSetting?: {
            global: {
                collapseWhitespace?: boolean;
                conservativeCollapse?: boolean;
                preserveLineBreaks?: boolean;
            };
            [filePath: string]: {
                collapseWhitespace?: boolean;
                conservativeCollapse?: boolean;
                preserveLineBreaks?: boolean;
            };
        };
        bundle?: boolean;
        userConfirmedBundleSwitch?: boolean;
        useIsolateContext?: boolean;
        userConfirmedUseIsolateContext?: boolean;
        useCompilerModule?: boolean;
        useMultiFrameRuntime?: boolean | string;
        useApiHook?: boolean;
        useApiHostProcess?: boolean;
        userConfirmedUseCompilerModuleSwitch?: boolean;
        skeletonGenerateFilesWithoutConfirm?: boolean;
        packNpmManually?: boolean;
        packNpmRelationList?: Array<{
            packageJsonPath: string;
            miniprogramNpmDistDir: string;
        }>;
        enableEngineNative?: boolean;
        useStaticServer?: boolean;
        minifyWXSS?: boolean;
        disableUseStrict?: boolean;
        minifyWXML?: boolean;
        useLanDebug?: boolean;
        showES6CompileOption?: boolean;
        useCompilerPlugins?: false | Array<string | [string, {
            [key in string]: any;
        }]>;
        useSummerCompiler?: false | Array<string | [string, {
            [key in string]: any;
        }]>;
        ignoreUploadUnusedFiles?: boolean;
        ignoreCodeQuality?: boolean;
        ignoreDevUnusedFiles?: boolean;
        bigPackageSizeSupport?: boolean;
    }
    interface IPluginInfo {
        provider: string;
        version: string;
    }
}
