/// <reference types="node" />
import type { Analyzer } from '../common/code-analyse';
import { MiniProgramDevtools } from './devtools';
import { MiniProgramCI } from './ci';
export * from './miniprogram-json/index';
export declare namespace MiniProgramCore {
    type IStat = MiniProgramCI.IStat;
    type ProjectType = MiniProgramCI.ProjectType;
    type IProjectArchitecture = MiniProgramCI.IProjectArchitecture;
    type ITargetPlatformDefine = {
        [key: string]: any;
    };
    type ITargetPlatform = 'mini-android' | 'mini-ios' | 'mini-weixin';
    type IPreRunEnv = 'main process' | 'summer cp' | 'worker cp';
    interface IConditionCompileInfo {
        targetPlatform?: ITargetPlatform;
        targetPlatformDefines?: ITargetPlatformDefine;
        runEnv?: IPreRunEnv;
    }
    interface IFileInfos {
        [key: string]: IStat;
    }
    interface IProjectSerializeInfo {
        appid: string;
        attr: any;
        type: ProjectType;
        projectPath: string;
        projectArchitecture: MiniProgramCore.IProjectArchitecture;
        miniprogramRoot: string;
        pluginRoot: string;
        files: string[];
        dirs: string[];
        setting: any;
    }
    interface IPrecompileProjectSerializeInfo extends IProjectSerializeInfo {
        targetPlatform: ITargetPlatform;
        targetPlatformDefines: ITargetPlatformDefine;
    }
    interface IProject extends MiniProgramCI.IProject {
        pluginSrcPath: string;
        serialize: () => Promise<IProjectSerializeInfo>;
        getTargetPath: (prefix: string, filePath: string) => string;
        exists: (prefix: string, filePath: string) => boolean;
        updateFileAndDirs: (...args: any[]) => void;
        getAllFileInfo: (prefix?: string) => IFileInfos;
        onFileChange?: any;
    }
    type IGetPackageFilesOptions = {
        graphId: ProjectType;
        root: string;
    };
    interface IPreCompileProject extends IProject {
        project: MiniProgramCI.IProject;
        targetPlatform?: ITargetPlatform;
        targetPlatformDefines?: ITargetPlatformDefine;
        conditionCompiler?: any;
        updateOptions(options: MiniProgramDevtools.IDevtoolsProjectInfo): void;
        getSrcFile(prefix: string, filePath: string): Buffer;
    }
    interface IStringKeyMap<T = any> {
        [propName: string]: T;
    }
    interface IValidateResult {
        warning: string;
        error: Array<{
            errorType: string;
            errorProperty: string;
            correctType?: string[];
            requireProperty?: string;
        }>;
    }
    type FN<R = any> = (...args: any[]) => R;
    type FN1<A = any, R = any> = (a: A) => R;
    type FN2<A = any, B = any, R = any> = (a: A, b: B) => R;
    type FN3<A = any, B = any, C = any, R = any> = (a: A, b: B, c: C) => R;
    type FN4<A = any, B = any, C = any, D = any, R = any> = (a: A, b: B, c: C, d: D) => R;
    interface IAnyObject {
        [key: string]: any;
    }
    type ICompileSettings = MiniProgramCI.ICompileSettings;
    type IResultType = 'prod' | 'dev' | 'preview';
    interface ITaskStatus {
        id: string;
        message: string;
        status: MiniProgramDevtools.IBuildLogType;
    }
    interface IDevToolsCompileCache {
        init: (project: IProject) => Promise<void>;
        get: (key: string) => any;
        set: (key: string, value: any) => void;
        remove: (key?: string | undefined) => void;
        getFile: (filePath: string, infoKey?: string) => Promise<any>;
        setFile: (filePath: string, value: any, infoKey?: string) => void;
        removeFile: (filePath: string) => void;
        clean: () => void;
        getAllCacheFiles: () => string[];
    }
    interface IDevtoolsDebugInfo {
        from: 'devtools' | 'ci' | 'inner';
        useNewCompileModule: boolean;
        devtoolsVersion: string;
        compileSetting: MiniProgramCore.IAnyObject;
        ciVersion?: string;
    }
    interface ICompileOptions {
        nameMapping?: IStringKeyMap<string>;
        setting?: MiniProgramDevtools.IProjectSetting;
        onProgressUpdate?: (task: ITaskStatus) => void;
        devToolsCompileCache?: IDevToolsCompileCache;
        __compileDebugInfo__?: IDevtoolsDebugInfo;
        compilePages?: string[];
        analyzer?: Analyzer;
        disableSpreadingUsingComponents?: boolean;
        resultType: IResultType;
        useCache?: boolean;
        targetPlatform?: 'mini-ios' | 'mini-android' | 'miniprogram';
    }
    interface ICompileOptionsWithFileList {
        nameMapping?: IStringKeyMap<string>;
        setting?: MiniProgramDevtools.IProjectSetting;
        fileList: string[];
        onProgressUpdate?: (task: ITaskStatus) => void;
        devToolsCompileCache?: IDevToolsCompileCache;
        __compileDebugInfo__?: IDevtoolsDebugInfo;
        compilePages?: string[];
        analyzer?: Analyzer;
        disableSpreadingUsingComponents?: boolean;
        resultType: IResultType;
    }
    type IProjectAttr = MiniProgramCI.IProjectAttr;
    interface IWarnItem {
        jsPath: string;
        code: string;
        tips: string;
        msg: string;
        startLine?: number;
        endLine?: number;
    }
    interface IPackNpmOptions {
        ignores?: string[];
        reporter?: MiniProgramCore.FN<void>;
    }
    type IWatchEventType = 'unlink' | 'unlinkDir' | 'add' | 'addDir' | 'change';
}
export type ProjectType = MiniProgramCore.ProjectType;
export type IProject = MiniProgramCore.IProject;
export type IStat = MiniProgramCore.IStat;
export type IAnyObject = MiniProgramCore.IAnyObject;
